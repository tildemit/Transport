# Reliable Transport Protocol

High-level approach: I represented my packets in this assignment as Python dictionaries, as they could be easily converted to and from JSON formats. The python starter code that was provided to me served as a major backbone for my implementation. The way I implemented the window for my program is my main addition to the starter code. I set the window as a simple number variable. I also set another variable that indicates the number of message that have been transitted that have not yet received acks. As my send program sends and receives acks, if the latter variable ever reaches the former variable, I stop sending messages and wait for an acknowledgement to extend the window further. In terms of detecting duplicate packets, I assign a sequence number to any outgoing message, with this number being unique for every message. Both the sender and and receiver keep track of which sequence numbers they have seen, and if they see a duplicate, they know to ignore that message. In regards to the receiver program, it works a bit more simply than the sender program. Every time it receives a valid message, ait sends an ack back to the sender and stores the data. Once the sender has sent all of its messages, it sends a "done" message over to the receiver. Then, the receiver sorts its list of data by sequence number, and prints out the data in order. Then, the receiver sends its own "done" message back to the sender. Once the sender sees this message, it safely exits the program. In terms of handling corrupted data, an adler32 algorithm is used on the data and sequence number on the sender's messages, and a combination of ack and sequence number is used on the receiver's messages as checksums. This way, it can be verified if a message's data contents are valid by recalculating the checksum using the message's fields. In terms of RTT, a a start time is tied to every outbound sender message. Once the sender receives an acknowledgement back for that message, it checks how much time has passed. If it is over the RTO (constantly recalculated over the course of the program) then the message gets retransmitted. The window size gets halved when a message needs to be retransmitted, and gets incremented when it receives a successful ack. These are the essentials of this program. 

Challenges: I had a few challenges over the course of creating this program. One of my main challenges was exceeding the alotted timers for the program tests. This was before I had implemented the system where I kept track of the window size and the number of messages currently in the network. After implementing these features, I was able to control how many messages I sent at a time (within the constraints of the window) and send messages at a faster rate. Unfortunately, this ultimately led to a different issue where I was getting many packet drops in my tests. I found that I needed to pay closer attention to the rate at which I sent my messages, and also realized that using the RTT to retransmit messages would be an essential tool to minimize packet losses. Packet losses continued to be a bit of an issue throughout the project, but implementing more features throughout the assignment such as the checksum greatly helped in this regard.

Good Features:
- Storing all messages in the receiver, to easily print out every message in sequence order at the end
- Keeping window and current un-ack'd message count variables, so that they can be easily changed and accessed
- Using adler32 to create checksums, with these checksums being relatively small 32-bit numbers to reduce data cost
- Looping through un-ack'd messages to see if any need to be retransmitted, potentially being able to retransmit multiple messages at a time

Testing: I generally followed the testing protocol meticulously laid out in the project description. I slowly evolved from the simple stop-and-wait protocol in the starter code to implement all the features. The testng scripts in the code were a large help in finding bugs in my code. When I was implementing my "done" messaged I talked about in the high-level description, at first things weren't working. From the testing results, I saw that I wasn't actually printing anything. I found that i wasn't properly sending the "done" message from the sender to the receiver, meaning the receiver wasn't getting any sort of hint to print the data. There were many other moments like this throughout the testing process. I was nervous when I found that going through the steps laid out in the project description made me start to fail earlier tests, but as I went further on, the added features of the project started to fix these errors.
